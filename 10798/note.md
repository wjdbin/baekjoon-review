# 📝 [백준 10798] 세로읽기 오답노트

## 1. 문제 분석 & 나의 초기 접근
* **문제:** 5줄의 단어를 입력받아 세로로 읽어서 출력해야 함.
* **나의 고민:** "입력받는 글자 수가 제각각인데, `malloc`으로 동적 할당을 해야 하나?"
* **해결책:** 문제 조건상 최대 15글자, 5줄로 크기가 작고 고정됨. 굳이 복잡한 `malloc` 대신 **넉넉한 크기의 정적 배열(`char[5][16]`)**을 쓰는 것이 훨씬 효율적임.

---

## 2. 핵심 개념 정리

### ① 배열 초기화의 중요성 (`{0}`)
* **문제점:** 각 줄마다 글자 수가 다름 (예: `ABC`, `Hello`). 입력 안 된 뒷부분에는 쓰레기 값이 들어있으면 안 됨.
* **해결:** `char arr[5][16] = {0};`
    * 선언과 동시에 **모든 칸을 NULL(`\0`)로 채워버림**.
    * 입력을 짧게 받아도, 뒷부분은 안전하게 `\0` 상태가 유지됨.

### ② 2차원 배열 입력받기 (`scanf`)
* **코드:** `scanf("%s", arr[i]);`
* **`%s`를 쓰는 이유:**
    * `%c`와 달리 **한 줄(문자열)을 통째로** 읽어옴.
    * 가장 중요한 점: 문자열 끝에 **자동으로 `\0`을 붙여줌** (마감 처리).
* **`arr[i]`의 의미:**
    * `arr[i][j]`는 '글자 하나'를 의미하지만,
    * `arr[i]`는 **i번째 행(줄) 전체의 시작 주소**를 의미함. 그래서 `&` 없이 사용 가능.

### ③ 세로 읽기 로직 (이중 for문 순서 뒤집기)
* 보통 읽기: `행(i) -> 열(j)` 순서
* **세로 읽기:** `열(j) -> 행(i)` 순서
    * 바깥 for문: `j` (0 ~ 14) // 열 고정
    * 안쪽 for문: `i` (0 ~ 4)  // 행 이동
* **조건:** `if (arr[i][j] != '\0')` 일 때만 출력 (빈칸 건너뛰기).

---

## 3. 최종 정답 코드 (C)

```c
#include <stdio.h>

int main() {
    // 1. 초기화: 모든 값을 NULL로 채움 ({0} 활용)
    char words[5][16] = {0}; 

    // 2. 입력: 줄 단위로 입력받기 (%s 사용)
    for (int i = 0; i < 5; i++) {
        scanf("%s", words[i]); // words[i]는 i번째 줄의 주소
    }

    // 3. 출력: 세로 방향으로 읽기 (열 우선 탐색)
    for (int j = 0; j < 15; j++) {      // 열(Column)
        for (int i = 0; i < 5; i++) {   // 행(Row)
            // 빈 공간(NULL)이 아닐 때만 출력
            if (words[i][j] != '\0') {
                printf("%c", words[i][j]);
            }
        }
    }
    return 0;
}
