📘 백준 2675번 문자열 반복 — 오답노트 (C)
문제

문자열 S의 각 문자 S[i]를 정수 R번씩 반복해 새 문자열을 만들어 출력하는 문제.

입력: 테스트케이스 수 T, 이후 각 줄에 R S (공백 구분, S는 공백 없음)

출력: 각 테스트케이스마다 변환된 문자열 한 줄

예시

입력
2
3 ABC
5 /HTP

출력
AAABBBCCC
/////HHHHHTTTTTPPPPP

❌ 내가 틀린 부분

입력 포맷 오사용 (%d %c)

%c는 문자 1개만 읽음 → 문자열은 **%s**로 받아야 함.

문자열 길이 제한 미설정

char S[21]이면 최대 20글자 + 널문자. **%20s**로 제한 필요.

문자열 종료 조건 표기

S[i] != 0도 동작하지만 **S[i] != '\0'**이 더 명확.

(자주 나는 실수) 문자를 곱해서 출력

printf("%c", S[i] * R); ❌ → 문자의 ASCII 값에 곱셈이 됨.

정답: 같은 문자를 R번 반복 출력.

✅ 올바른 사용법 정리

문자열 입력(안전): scanf("%d %20s", &R, S);

반복 출력: printf("%c", S[i]);를 R번 수행

테스트케이스마다 \n 출력

🧩 정답 코드 (C)
#include <stdio.h>

int main(void)
{
    int T;
    scanf("%d", &T);

    for (int tc = 0; tc < T; tc++) {
        int R;
        char S[21];                    // 최대 20글자 + '\0'
        scanf("%d %20s", &R, S);       // 길이 제한으로 오버런 방지

        for (int i = 0; S[i] != '\0'; i++) {
            for (int j = 0; j < R; j++) {
                printf("%c", S[i]);    // 같은 문자를 R번 출력
            }
        }
        printf("\n");                  // 케이스마다 줄바꿈
    }
    return 0;
}

✅ 체크리스트

 문자열은 %s로 입력

 char S[21] → "%20s" 길이 제한

 반복은 곱셈이 아니라 동일 문자 R번 출력

 종료 조건은 '\0'

 각 케이스 끝에 \n 출력

🔑 한 줄 요약

문자열은 %s로 안전하게 받고(%20s), 각 문자를 R번 그대로 출력한다.
