# 📝 오답노트: 백준 2563번 - 색종이

## 1. 문제 정보
- **문제 번호**: 2563
- **문제 이름**: 색종이
- **사용 언어**: C
- **알고리즘 분류**: 구현, 2차원 배열

## 2. 틀린 이유 (Bug Report)
**"입력받는 반복문과 로직을 처리하는 반복문을 분리했다."**

변수 `x`, `y`는 입력을 받을 때마다 새로운 값으로 갱신된다.  
입력 루프가 다 끝난 뒤에 색칠 루프를 돌리면, **마지막에 입력받은 `x`, `y` 값만 남고 이전 입력값들은 사라진다.** 결국 색종이가 딱 1장만 붙게 되는 논리적 오류가 발생했다.

## 3. 코드 비교 (Code Review)

### ❌ 틀린 코드 (Wrong Logic)
> 입력을 전부 다 받은 뒤에 처리를 시도함.

```c
// 색종이 개수(n)만큼 반복
for (int k = 0; k < n; k++) {
    scanf("%d %d", &x, &y); // 여기서 x, y가 계속 덮어씌워짐
}

// 반복문이 끝난 뒤 실행 -> 마지막 x, y만 남음!
for (int i = x; i < x + 10; i++) {
    for (int j = y; j < y + 10; j++) {
        paper[i][j] = 1;
    }
}
```
### ✅ 고친 코드 (Correct Logic)
> 입력을 받자마자 즉시 배열에 처리(마킹)함.

```c
// 색종이 개수(n)만큼 반복
for (int k = 0; k < n; k++) {
    scanf("%d %d", &x, &y); // 좌표 입력 받음

    // 입력받은 즉시! 해당 영역 색칠하기
    for (int i = x; i < x + 10; i++) {
        for (int j = y; j < y + 10; j++) {
            paper[i][j] = 1;
        }
    }
} // 다음 입력 받으러 올라감
```
## 4. 핵심 포인트 (Key Takeaway)
* **데이터의 휘발성**: `scanf`로 변수에 값을 새로 받으면 이전 값은 지워진다.
* **즉시 처리**: 데이터를 따로 저장(배열 등)해둘 게 아니라면, 입력받은 그 `scope`(범위) 안에서 로직을 수행하고 넘어가야 한다.
* **배열 초기화**: `int paper[101][101] = {0, };` 로 초기화해야 쓰레기 값이 안 들어간다.
