# 📘 백준 10811번 오답노트

## 문제 요약
1번부터 N번까지 바구니가 있고, 처음엔 각 바구니에 자기 번호가 들어 있다.  
M번 주어지는 구간 `(a, b)`마다 **바구니 [a..b] 안의 숫자 순서를 뒤집어야 한다.**  
모든 연산을 끝낸 뒤 바구니에 들어있는 숫자를 공백으로 출력한다.

---

## ❌ 내가 틀린 부분
- **구간 뒤집기 로직 오해**  
  `arr[a-1] = b; arr[b-1] = a;` 처럼 **양 끝 값만 교환**하려고 했다.  
  하지만 실제 요구사항은 `[a..b]` 구간 전체를 뒤집는 것.

- **swap(교환) 구현 실수**  
  임시 변수 없이 `arr[L] = arr[R]; arr[R] = arr[L];`를 쓰면  
  원래 값이 사라져서 오답 발생.

- **인덱스 혼동 (0-based vs 1-based)**  
  배열은 기본적으로 0부터 시작하지만, 문제의 바구니 번호는 1부터 시작한다.  
  따라서 0-based로 구현한다면 반드시 `a-1`, `b-1`로 변환해야 한다.  
  1-based 배열로 선언하면 조금 더 직관적.

- **출력 형식 문제**  
  단순히 `printf("%d ", arr[i]);`를 쓰면 마지막에 공백이 붙는다.  
  대부분은 통과하지만, 안전하게는 **마지막 원소 뒤엔 공백을 빼는 방식**이 좋다.  

---

## ✅ 수정한 점
- 구간 [a..b]를 뒤집을 때 **양 끝에서 안쪽으로 좁혀가며 swap**:
  ```c
  int L = a, R = b;
  while (L < R) {
      tmp = arr[L];
      arr[L] = arr[R];
      arr[R] = tmp;
      L++;
      R--;
  }
