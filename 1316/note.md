# 🔑 백준 1316번 (그룹 단어 체커) 핵심 로직

이 문제는 "그룹 단어가 **아닌** 조건"을 찾아내는 것이 중요합니다.

---

## 1. 언제 검사하는가?
* `a**a**bb` 처럼 **이전 글자와 현재 글자가 같을 땐** 볼 필요가 없습니다. 어차피 그룹이 이어지고 있으니까요.
* `aa**b**` 처럼 **이전 글자와 현재 글자가 달라지는 순간**이 바로 검사 시점입니다.

## 2. 무엇을 검사하는가?
* 알파벳 26칸짜리 배열(`visited[26]`)을 만들어 **"이미 등장했던"** 문자를 기록합니다.
* 글자가 달라지는 순간 (예: `...b**a**`), 이 `a`가 `visited` 배열에 **이미 등장(`1`)했다고 표시되어 있는지** 확인합니다.

## 3. 판단 (핵심)
* **실패:** 글자가 달라졌는데 (`...b**a**`), `visited['a']`를 보니 **이미 `1`이다?**
    * → `aba`처럼 이전에 나왔던 문자가 중간에 다른 게 끼고 또 나온 것입니다.
    * → **그룹 단어 실패!** 이 단어는 검사를 중지합니다.
* **성공 (계속):** 글자가 달라졌는데 (`aa**b**`), `visited['b']`를 보니 `0` (처음)이다?
    * → 새로운 문자 그룹이 시작된 것입니다.
    * → `visited['b'] = 1`로 방문 표시만 하고 계속 진행합니다.

---

### C언어 기준 요약
* `int visited[26] = {0};` 배열을 준비합니다.
* 단어의 첫 글자는 `visited`에 `1`로 표시하고 시작합니다.
* 두 번째 글자부터 `for`문을 돕니다.
* `if (word[j] != word[j-1])` (문자가 달라졌을 때)
    * `if (visited[word[j] - 'a'] == 1)` (근데 이미 방문한 적이 있다면?)
        * → **그룹 단어 아님!** (`break`)
    * `else` (처음 나온 문자라면?)
        * → `visited[word[j] - 'a'] = 1;` (방문 표시)

**가장 중요한 것:** 이 `visited` 배열은 **새로운 단어를 검사할 때마다 매번 0으로 초기화**해야 합니다.

![1316](https://github.com/user-attachments/assets/00037b89-c303-4cee-a7c5-d448663cd336)
